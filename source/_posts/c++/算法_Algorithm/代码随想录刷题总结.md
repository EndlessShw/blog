# 代码随想录笔记

## 1. 数组

### 1.1 二分查找

#### 1.1.1 代码

```cpp
// 二分法
#include <iostream>
using namespace std;

// 题目：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target，
// 写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

int target = 10;
int nums[] = { -1, 2, 5, 7, 10 };

/*
* 二分的区间是 [left, right]，左闭右闭
* @return 返回下标，找不到就返回 -1
*/
int divLeftAndRight(int* nums, int length)
{
	// 定义左边界和右边界
	int left = 0;
	int right = length - 1;
	// 当区间定义为左闭右闭时，left == right 区间是“合法”的，while 循环查找的条件为“合法”条件
	while (left <= right) {
		int middle = (left + right) / 2;
		// 如果中间值大于目标值，说明两点：
		//    1. 中间值不等于目标值
		//    2. 目标值在左区间
		if (nums[middle] > target)
		{
			// 根据第一点，不等于目标值，再加上区间是闭区间，那么区间的右边就不要是 middle 了，
			// 不然会把不相等的值带到下轮循环，边界处理就会有问题
			right = middle - 1;
		}
		else if (nums[middle] < target)
		{
			// 理论同上
			left = middle + 1;
		}
		// 相等就返回下表
		else return middle;
	}
	return -1;
}

/*
* 合法区间为 [left, right)
*/
int divLeft(int* nums, int length)
{
	// 定义左边界和右边界
	int left = 0;
	// 这里有个注意点，当定义为左闭右开时，right 取 length，才能把最后一个元素包含在内
	int right = length;
	// 当区间定义为左闭右开时，left == right 区间是“不合法”的，while 循环查找的条件为“合法”条件
	while (left < right)
	{
		int middle = (left + right) / 2;
		// 左区间
		if (nums[middle] > target)
		{
			// 因为右开，所以 right 取 middle 后，他也不在“合法”的区间内，所以就不用 + 1 了
			right = middle;
		}
		else if (nums[middle] < target)
		{
			// 因为左闭，所以 left 不能取 middle
			left = middle + 1;
		}
		else return middle;
	}
	return -1;
}

int main()
{
	// 获取数组长度
	int n = sizeof(nums) / sizeof(int);
	int pivot = divLeftAndRight(nums, n);
	cout << "下标值为：" << pivot << endl;
	pivot = divLeft(nums, n);
	cout << "下标值为：" << pivot << endl;
}

// 要点总结：
//   1. 一定要统一区间的定义，一般都是 [left, right) 或者 [left, right]。
//      一旦统一了这个区间的定义，那么边界值（left, right）的赋值以及区间“合法”的判断方式，
//      就能随之定义下来
//   2. 区间的定义就是不变量。
//      要在二分查找的过程中，保持不变量，就是在 while 寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。
```

#### 1.1.2 要点总结

1. 一定要统一区间的定义，一般都是 [left, right) 或者 [left, right]。一旦统一了这个区间的定义，那么边界值（left, right）的赋值以及区间“合法”的判断方式，就能随之定义下来。即对于这种循环分组的算法，一定要满足**循环不变量**。
2. 区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在 `while` 寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是**循环不变量**规则。

### 1.2 移除元素

#### 1.2.1 代码

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 题目：给你一个数组 nums 和一个值 val，你需要“原地”移除所有数值等于 val 的元素，
// 并返回移除后数组的新长度。
// 不要使用额外的数组空间，仅使用 O(1) 额外空间并原地修改输入数组。
// 例如：给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

// 算法一：暴力破解（用 vector 的库函数）
void bruteForce(vector<int> &nums, const int val)
{
    for (int i = 0; i < nums.size(); i++)
    {
        if (nums[i] == val)
        {
            // 删去一个元素，并将所有元素向前挪一位，size-- 但 capacity 不变
            nums.erase(nums.begin() + i);
            i--;
        }
    }
}
// 算法二：暴力破解（数组）
int* bruteForce(int* nums, const int val, int& length)
{
    for (int i = 0; i < length; i++)
    {
        if (nums[i] == val)
        {
            for (int j = 0; j < length - i; j++)
            {
                nums[i + j] = nums[i + j + 1];
            }
            i--; length--;
        }
    }
    return nums;
}

// 算法三：双指针法
int* doublePointer(int* nums, const int val, int& length)
{
    // slow 指针指向被删除元素，相当于是新数列元素的所在位置
    int slowPointer = 0;
    int oldLength = length;
    // fast 指针指向删除元素后新数列的元素
    for (int fastPointer = 0; fastPointer < oldLength; fastPointer++)
    {
        if (nums[fastPointer] != val)
        {
            // 只要值不相同就覆盖
            nums[slowPointer] = nums[fastPointer];
            slowPointer++;
        }
    }
    // 最终 slowPointer 指向新数组的后一个元素
    length = slowPointer;
    return nums;
}
int main()
{
    vector<int> nums = { 0, 1, 2, 2, 3, 0, 4, 2 };
    int val = 2;
    bruteForce(nums, val);
    cout << "nums 为：" << "    ";
    for (int i = 0; i < nums.size(); i++)
    {
        cout << nums[i] << "    ";
    }
    cout << endl << endl;

    int length = 8;
    int* nums2 = new int[length] { 0, 1, 2, 2, 3, 0, 4, 2 };
    int* nums2_ = bruteForce(nums2, val, length);
    cout << "长度为：" << length << endl;
    cout << "nums2 为：" << "    ";
    for (int i = 0; i < length; i++)
    {
        cout << nums2_[i] << "    ";
    }
    cout << endl << endl;
    
    int length2 = 8;
    int* nums3 = new int[length2] { 0, 1, 2, 2, 3, 0, 4, 2 };
    int* nums3_ = doublePointer(nums3, val, length2);
    cout << "长度为：" << length2 << endl;
    cout << "nums3 为：" << "    ";
    for (int i = 0; i < length2; i++)
    {
        cout << nums3_[i] << "    ";
    }
    cout << endl;
}
```

#### 1.2.2 要点总结

1. 双指针的本质作用在于**在一个 `for` 循环下完成两个 `for` 循环的工作。**从而可以在空间复杂度不变的情况下缩短时间复杂度。
2. 库函数中 `erase()` 的效率是 `O(n)`，因此效率不高。

### 1.3 有序数组的平方

#### 1.3.1 代码

```cpp
#include <iostream>
using namespace std;
// 按 非递减顺序 排序的整数数组 nums，
// 返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

// 算法：双指针
// 因为得到的新数组的规律就是旧数组的最大值，而旧数组的最大值在两端，因此采用双指针
void doublePointer(int* const nums, int length, int* newNums)
{
    int head = 0;
    int tail = length - 1;
    for (int i = 0; i < length; i++)
    {
        if (nums[head] * nums[head] < nums[tail] * nums[tail])
        {
            newNums[length - 1 - i] = (nums[tail] * nums[tail]);
            tail--;
        }
        else
        {
            newNums[length - 1 - i] = (nums[head] * nums[head]);
            head++;
        }
    }
}
int main()
{
    int length = 5;
    int* nums = new int[length]{ -5, -2, 1, 3, 4 };
    int* newNums = new int[length];
    doublePointer(nums, length, newNums);
    for (int i = 0; i < length; i++)
    {
        cout << newNums[i] << "  ";
    }
    cout << endl;
}
```

#### 1.3.2 要点总结

1. 双指针的另一种形式的运用 -- “从逻辑、算法本质的角度”。

### 1.4 长度最小的子数组

#### 1.4.1 代码

```cpp
#include <iostream>
using namespace std;

// 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。
// 如果不存在符合条件的子数组，返回 0。

// 算法思想：滑动窗口（双指针）
int doublePointer(const int* nums, const int length, const int target, int& shortest)
{
    int head = 0;
    int tail = 0;
    int total = 0;
    // 区间左闭右闭
    int gap = length + 1;
    // 可以使用 for 循环，这样不仅 tail++ 自动完成，而且 total += nums[tail] 与 tail++ 先后次序不会乱
    // 此时外层的 if 也可以去掉
    while (tail < length)
    {
        if (total < target)
        {
            total += nums[tail];
            tail++;
            if (total > target)
            {
                // 如果再加之后大于等于了，说明目前得到的是暂时的最短值
                while (total >= target)
                {
                    total -= nums[head];
                    head++;
                }
                // 说明最后一次 head++ 前是最短的，那就暂替
                if (tail - head + 2 <= gap)
                {
                    gap = tail - head + 2;
                    shortest = head - 1;
                }
            }
        }
        cout << "tail is " << tail << endl;
    }
    if (total < target)
    {
        return 0;
    }
    return gap;
}

// 算法思想：滑动窗口（双指针）
int doublePointerImproved(const int* nums, const int length, const int target, int& shortest)
{
    int head = 0;
    int tail = 0;
    int total = 0;
    // 区间左闭右闭
    int gap = length + 1;
    // 可以使用 for 循环，这样不仅 tail++ 自动完成，而且 total += nums[tail] 与 tail++ 先后次序不会乱
    // 此时外层的 if 也可以去掉
    for (; tail < length; tail++)
    {
        total += nums[tail];
        while (total > target)
        {
            // 这里的先后逻辑还可以是：
            // 先进行判断赋值，然后再进行 total 和 head 的变化，
            total -= nums[head];
            head++;
            // 这里在超过 2 次以上缩短时，就会重复，因此想要减少次数的话就使用双 if
            // 说明最后一次 head++ 前是最短的，那就暂替
            if (tail - head + 2 <= gap)
            {
                gap = tail - head + 2;
                shortest = head - 1;
            }
        }

    }
    if (total < target)
    {
        return 0;
    }
    return gap;
}

int main()
{
    int target = 7;
    int length = 6;
    int shortest = 0;
    int* nums = new int[length] {2, 3, 1, 2, 4, 3};
    int gap = doublePointerImproved(nums, length, target, shortest);
    if (gap == 0)
    {
        cout << "不符合条件" << endl;
    }
    else
    {
        cout << "最小的集合为：" << endl;
        for (int i = 0; i < gap - 1; i++)
        {
            cout << nums[shortest + i] << "  ";
        }
        cout << endl;
        cout << "最短长度为：" << gap - 1;
    }
}

// 总结：双指针主要用于解决两层循环，O(n^2) 的效率问题，用小空间省大时间。
//       有时双指针需要数组等结构有序，这里需要注意一下。
```

#### 1.4.2 要点总结

1. 双指针的特殊形式：**动态滑动窗口**。

## 2. 链表

### 2.1 翻转链表

#### 2.1.1 代码

```cpp
// 翻转链表
#include <iostream>
using namespace std;

struct ListNode
{
    int val;
    ListNode* next;
    ListNode() : val(0), next(nullptr) {};
    ListNode(int val) : val(val), next(nullptr) {};
    ListNode(int val, ListNode* next) : val(val), next(next) {}
};
/**
 * 带头节点的链表翻转.
 * 
 * \param head
 * \return 
 */
ListNode* reverseList(ListNode* head) {
    if (!head)
    {
        return head;
    }
    // head 一直指向头位
    // 用双指针
    ListNode* before = head;
    ListNode* after = head->next;
    while (after)
    {
        // todo 节点交换也可以考虑只换节点内的数据
        // 每一轮前段的尾节点指向后一段首节点的第二个点
        before->next = after->next;
        // 后一段首节点指向前一段的首节点
        after->next = head;
        // head 要变成首部
        head = after;
        // after 后移一位
        after = before->next;
    }
    return head;
}

int main()
{
    // 注意 head 是指针，他初始化时就可以指向一个节点。head 的内容就是节点
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);
    head = reverseList(head);
    cout << head->next->val << " "
        << head->next->next->val << " "
        << head->next->next->next->val << " "
        << head->next->next->next->next->val << " "
        << endl;
}
```

#### 2.1.2 要点总结

1. 注意首节点指针 head 的定义：
    `ListNode* head = new ListNode(1);`
    注意不能犯浑 -- “忘记指针的意义”。
2. 交换链表的两个节点，除了改节点的 `next` ，也可以让 `next` 方向相反，然后**交换节点内容**。

### 2.2 删除链表倒数的第 N 个节点

#### 2.2.1 代码

```cpp
// 删除倒数的节点
#include <iostream>
using namespace std;

struct ListNode
{
    int val;
    ListNode* next;
    ListNode() : val(0), next(nullptr) {};
    ListNode(int val) : val(val), next(nullptr) {};
    ListNode(ListNode* next) : val(0), next(next) {};
    ListNode(int val, ListNode* next) : val(val), next(next) {};
};

ListNode* removeNthFromEnd(ListNode* head, int n) {
    // 设立一个头节点，从而方便操作
    ListNode* fakeHead = new ListNode(head);
    head = fakeHead;
    ListNode* after = fakeHead;
    for (int i = 0; i < n; i++)
    {
        after = after->next;
    }
    while (after->next)
    {
        after = after->next;
        head = head->next;
    }
    // 此时 head 为待删除节点的前一个节点
    after = head->next;
    // 删 after 所指向的节点
    head->next = after->next;
    after->next = nullptr;
    delete after;
    // head 也要删除
    head = nullptr;
    delete head;
    return fakeHead->next;
}

int main()
{
    ListNode* head = new ListNode(1);
    head = removeNthFromEnd(head, 1);
    cout << head->val << endl;
}

```

#### 2.2.2 要点总结

1. 但凡涉及对链表的数量进行操作的算法，一定要**单独**考虑首节点和尾节点的处理，为了方便，必要时可添加**虚拟头节点**。

## 3. 双指针

### 3.1 之前涉及到的

1. [1.2 移除元素](#1.2 移除元素) - 两个 `for`
2. [1.3 有序数组的平方](#1.3 有序数组的平方) - 逻辑与本质角度
3. [1.4 长度最小的子数组](#1.4 长度最小的子数组) - 动态滑动窗口
4. 以及链表的相关题目。

### 3.2 替换空格

#### 3.2.1 代码

```cpp
// 替换字符串中的空格
#include <iostream>
#include <string>
using namespace std;

int getSpaceNum(const string& s)
{
	int count = 0;
	for (int i = 0; i < s.length(); i++)
	{
		if (s[i] == ' ')
		{
			count++;
		}
	}
	return count;
}

string getReplacedStr(string& s)
{
	int spaceNum = getSpaceNum(s);
	int pointer = s.size() - 1;
	s.resize(s.size() + 2 * spaceNum);
	for (int i = s.size() - 1; i >= 0; i--)
	{
		// i 是新长度指针
		// pointer 是旧长度指针
		if (s[pointer] != ' ')
		{
			s[i] = s[pointer];
		}
		else
		{
			s[i] = '0';
			s[i - 1] = '2';
			s[i - 2] = '%';
			i -= 2;
		}
		pointer--;
	}
	return s;
}

int main()
{
	string s = "We are happy.";
	cout << getReplacedStr(s) << endl;
}
```

#### 3.2.2 要点总结

1. 对于将字符串边长的算法，优先考虑先扩充，然后运用双指针从后向前来写新的字符串，这样空间复杂度就不会很高。
2. `str.resize(int newSize)` 当新的尺寸小于原来的，末尾会**被截断**。这点要注意。

### 3.3 翻转字符串内的单词

#### 3.3.1 代码

```cpp
// 规格化并翻转字符串内的单词
#include <iostream>
#include <string>
using namespace std;

/**
 * 前后去掉空格，然后还要去除单词中的多余空格
 * 
 * \param str
 */
void formatStr(string& str)
{
    // 由于是缩短字符串，所以直接对其进行修改
    int slowPointer = 0;
    // 统计开头的空格
    int spaceBef = 0;
    for (int i = 0; i < str.size(); i++)
    {
        if (str[i] == ' ')
        {
            spaceBef++;
        }
        else
        {
            break;
        }
    }
    // 去掉末尾的空格
    int spaceAft = 0;
    for (int i = str.size() - 1; i >= 0; i--)
    {
        if (str[i] == ' ')
        {
            spaceAft++;
        }
        else
        {
            break;
        }
    }
    str.resize(str.size() - spaceAft);
    // 对字符串进行整形
    int resultLength = 0;
    for (int i = spaceBef; i < str.size(); i++)
    {
        // 判断他前一位是不是空格
        if (str[i] != ' ' || (str[i] == ' ' && str[i - 1] != ' '))
        {
            str[slowPointer] = str[i];
            slowPointer++;
            resultLength++;
        }
    }
    str.resize(resultLength);
}

string reverseWords(string s)
{
    // 首先将字符串进行规则化
    formatStr(s);
    // 然后对其进行翻转
    int begin = 0;
    int end = s.size() - 1;
    while (begin <= end)
    {
        char temp = s[begin];
        s[begin] = s[end];
        s[end] = temp;
        begin++;
        end--;
    }
    cout << s << endl;
    // 双指针再单词内翻转
    begin = 0;
    for (int i = 0; i < s.size(); i++)
    {
        if (s[i + 1] == ' ' || i == s.size() - 1)
        {
            end = i;
            while (begin <= end)
            {
                char temp = s[begin];
                s[begin] = s[end];
                s[end] = temp;
                begin++;
                end--;
            }
            begin = i + 2;
        }
    }
    return s;
}

int main()
{
    string s = "the sky is blue";
    //formatStr(s);
    cout << reverseWords(s) << endl;

}
```

#### 3.3.2 要点总结

1. 细节很多，重点思路是基于“双指针翻转字符串”。

## 4. 栈和队列

### 4.1 有效括号

#### 4.1.1 代码

```cpp
// 用栈对括号字符串进行有效判定
#include <iostream>
#include <stack>
#include <string>
using namespace std;

bool isEffectiveBracket(string s)
{
	if (s.empty())
	{
		return true;
	}
    stack<char> bracketStack;
	// 如果长度为奇数，那直接就有问题
	if (s.length() % 2 != 0 || s[0] == ')' || s[0] == ']' || s[0] == '}')
	{
		return false;
	}
	// 左括号直接进栈，如果遇到对应右括号，就出栈
	for (int i = 0; i < s.length(); i++)
	{
		// 如果是左括号就进栈
		if (s[i] == '(' || s[i] == '[' || s[i] == '{')
		{
			bracketStack.push(s[i]);
		}
		// 右括号就和栈顶进行匹配
		else
		{
			// 如果此时栈为空，说明不匹配，直接返回
			if (bracketStack.empty())
			{
				return false;
			}
			char temp = bracketStack.top();
			bracketStack.pop();
			if (s[i] == ')' && temp != '(')
			{
				return false;
			}
			if (s[i] == ']' && temp != '[')
			{
				return false;
			}
			if (s[i] == '}' && temp != '{')
			{
				return false;
			}
		}
	}
	if (!bracketStack.empty())
	{
		return false;
	}
	return true;
}

bool isEffectiveBracketPro(string s)
{
	if (s.empty())
	{
		return true;
	}
	stack<char> bracketStack;
	// 如果长度为奇数，那直接就有问题
	if (s.length() % 2 != 0 || s[0] == ')' || s[0] == ']' || s[0] == '}')
	{
		return false;
	}
	// 左括号翻转成右括号进栈，然后右括号来的时候出栈
	for (int i = 0; i < s.size(); i++)
	{
		if (s[i] == '(')
		{
			bracketStack.push(')');
			continue;
		}
		if (s[i] == '[')
		{
			bracketStack.push(']');
			continue;
		}
		if (s[i] == '{')
		{
			bracketStack.push('}');
			continue;
		}
		// 如果是右括号，那就要判断
		// 首先第一种情况，栈这个时候为空，那么说明右括号多出来了
		if (bracketStack.empty())
		{
			return false;
		}
		// 第二种情况，就是不匹配
		if (bracketStack.top() != s[i])
		{
			return false;
		}
		bracketStack.pop();
	}
	// 第三种情况，如果最后栈不为空，说明左括号多了
	if (!bracketStack.empty())
	{
		return false;
	}
	return true;
}

int main()
{
	string s = "()[]{}";
	bool isEffective = isEffectiveBracket(s);
	cout << isEffective << endl;
	s = "()";
	isEffective = isEffectiveBracketPro(s);
	cout << isEffective << endl;
}
```

####  4.1.2 要点总结

1. 拿到算法题要考虑清楚，将所有可能的情况理清再动笔。

### 4.2 删除字符串中的所有相邻重复项

#### 4.2.1 代码

```cpp
// 删除字符串中的所有相邻的重复项
#include <iostream>
#include <stack>
#include <string>
using namespace std;

string deleteDuplication(string s)
{
	if (s.empty())
	{
		return s;
	}
	stack<char> container;
	container.push(s[0]);
	for (int i = 1; i < s.length(); i++)
	{
		if (container.empty() || s[i] != container.top())
		{
			container.push(s[i]);
		}
		else
		{
			container.pop();
		}
	}
	string result;
	// 这样写效率反而低，不如翻转字符串
	/*while (!container.empty())
	{
		result = container.top() + result;
		container.pop();
	}*/
	while (!container.empty())
	{
		result += container.top();
		container.pop();
	}
	reverse(result.begin(), result.end());
	return result;
}

/**
 * 字符串直接作栈.
 * 
 * \param s
 * \return 
 */
string deleteDuplicationPro(string s)
{
	if (s.empty())
	{
		return s;
	}
	string result;
	result.push_back(s[0]);
	for (int i = 1; i < s.length(); i++)
	{
		if (result.empty() || s[i] != result.back())
		{
			result.push_back(s[i]);
		}
		else
		{
			result.pop_back();
		}
	}
	return result;
}

int main()
{
	string s = "abbaca";
	s = deleteDuplication(s);
	cout << s << endl;
}
```

#### 4.2.2 要点总结

1. 有时候未必一定要用 `stack`，`stack` 本身**是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。**即栈是有点“抽象”的，这题可以直接拿字符串当作栈使用。免去了栈最后转化成字符串的步骤。

### 4.3 逆波兰表达式求值

#### 4.3.1 代码

```cpp
// 逆波兰表达式求值
#include <iostream>
#include <stack>
#include <vector>
#include <string>
using namespace std;

int operate(const int& op1, const int& op2, string op)
{
	if (op == "*")
	{
		return op1 * op2;
	}
	if (op == "/")
	{
		return op1 / op2;
	}
	if (op == "+")
	{
		return op1 + op2;
	}
	if (op == "-")
	{
		return op1 - op2;
	}
	return 0;
}

int getRPNResult(vector<string>& tokens)
{
	stack<int> opNums;
	for (int i = 0; i < tokens.size(); i++)
	{
		try
		{
			// cpp 的函数，如果不包含数字就会抛出异常
			// 这里这样做是因为用 stoi 时，如果参数不含数字会返回 0，从而影响计算
			int num = stoi(tokens[i]);
			opNums.push(num);
		}
		catch (const std::invalid_argument)
		{
			// 先弹出的是右操作数
			int op1 = opNums.top();
			opNums.pop();
			int op2 = opNums.top();
			opNums.pop();
			opNums.push(operate(op2, op1, tokens[i]));
		}
	}
	return opNums.top();
}

/**
 * 改进：翻转思维 - 先判断四个符号，不是就直接转数字就行
 * 不用考虑 stol 内为字符串时的 0 问题.
 * 不用异常处理，从而加快速度
 * 
 * \param tokens
 * \return 
 */
int getRPNResultPro(vector<string>& tokens)
{
	stack<int> opNums;
	for (int i = 0; i < tokens.size(); i++)
	{
		if (tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/")
		{
			int op1 = opNums.top();
			opNums.pop();
			int op2 = opNums.top();
			opNums.pop();
			opNums.push(operate(op2, op1, tokens[i]));
		}
		else
		{
			int num = stol(tokens[i]);
			opNums.push(num);
		}
	}
	return opNums.top();
}

int main()
{
	vector<string> tokens = { "10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+" };
	cout << getRPNResult(tokens) << endl;
}
```

#### 4.3.2 要点总结

1. 重要的一点就是，逆波兰表达式中，**先出栈的操作数一定是右操作数**。

## 5. 二叉树

### 5.1 二叉树的递归遍历

#### 5.1.1 代码

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 二叉树的递归遍历
// 写遍历的思路：
//     1. 确定递归函数的参数和返回值（未必第一次写完）
//     2. 确定终止条件
//     3. 确定单层递归的逻辑

/*
* 二叉树节点
*/
struct BitNode
{
    int value;
    BitNode* left;
    BitNode* right;
    BitNode(int value) : value(value), left(NULL), right(NULL) {}
};

/*
* 前序遍历
* 1. 确定递归方法的参数
* @current 传入的节点
* @nodes 存放遍历时的节点数据
*/
void traverse(BitNode* current, vector<int>& nodes)
{
    // 2. 确定递归的退出条件
    if (current == NULL)
    {
        return;
    }
    // 3. 确定每次递归的运行逻辑
    // 前序遍历是“中左右”
    // 树的遍历中，“中”是要进行访问的(“向中间走”）。
    // “左”和“右”代表向左走和向右走
    // 中间的要将节点的内容存放在数组中（visit）
    nodes.push_back(current->value);
    // 左边的就要先遍历，要把左边的树遍历完
    traverse(current->left, nodes);
    // 左边遍历后，右边也得遍历
    traverse(current->right, nodes);
}

/*
* 后序遍历
* 1. 确定递归方法的参数
* @current 传入的节点
* @nodes 存放遍历时的节点数据
*/
void inverseTraverse(BitNode* current, vector<int>& nodes)
{
    // 2. 确定递归的退出条件
    if (current == NULL)
    {
        return;
    }
    // 3. 确定每次递归的运行逻辑
    traverse(current->left, nodes);
    traverse(current->right, nodes);
    nodes.push_back(current->value);
}

int main()
{
    BitNode headNode(3);
    BitNode leftNode(2);
    BitNode rightNode(4);
    headNode.left = &leftNode;
    headNode.right = &rightNode;
    vector<int> nodes;
    inverseTraverse(&headNode, nodes);
    for (int i = 0; i < nodes.size(); i++)
    {
        cout << nodes[i] << "  ";
    }
    cout << endl;
}
```

#### 5.1.2 要点总结

1. 递归的三大要素。
2. 遍历中，中节点是“遍历 + 访问”，而左右只有“遍历”。

### 5.2 二叉树的迭代遍历

#### 5.2.1 代码

```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>
using namespace std;

// 用非递归遍历树
// 系统本质上在实现递归时用的是栈，因此可以使用栈模拟递归操作。
// 用栈实现非递归本质就是模拟计算机实现递归

struct BitNode
{
    int value;
    BitNode* left;
    BitNode* right;
    BitNode(int value) : value(value), left(NULL), right(NULL) {}
};

/*
* 非递归还是要记住一点，中间节点是“访问”（向中间走），左右节点是向下走。
* 前序非递归遍历
*/
vector<int> preorderedTraverse(BitNode head)
{
    // 这个栈要求出栈后的顺序为遍历的顺序
    // 同时，出栈就代表着要访问节点（因为前序递归访问的顺序同遍历的顺序）
    stack<BitNode> nodeStack;
    vector<int> order;
    // 1. 头节点入栈
    // 需要注意一下，如果栈存的是 BitNode*，这里才能对 head 进行判断（此时 head 为指针）
    nodeStack.push(head);
    while (!nodeStack.empty())
    {
        // 2. 前序遍历，“中”出栈，访问
        BitNode node = nodeStack.top();
        order.push_back(node.value);
        nodeStack.pop();
        // 3. 右孩子入栈
        if (node.right != NULL)
        {
            nodeStack.push(*node.right);
        }
        // 4. 左孩子入栈
        if (node.left != NULL)
        {
            nodeStack.push(*node.left);
        }
        // 5. 回到第二点
        // 6. 结束条件：栈不为空
    }
    return order;
}

/*
* 后序遍历的思路：
*     在前序遍历的基础上，中左右 -> 中右左 -> 左右中
*/
vector<int> afterOrderedTraverse(BitNode head)
{
    stack<BitNode> nodeStack;
    vector<int> order;
    // 1. 头节点入栈
    // 需要注意一下，如果栈存的是 BitNode*，这里才能对 head 进行判断（此时 head 为指针）
    nodeStack.push(head);
    while (!nodeStack.empty())
    {
        BitNode node = nodeStack.top();
        order.push_back(node.value);
        nodeStack.pop();
        // 这里就是将先左后右进栈，实现中右左
        // 注意这里空节点是不入栈的，要和中序遍历区分开
        if (node.left != NULL)
        {
            nodeStack.push(*node.left);
        }
        if (node.right != NULL)
        {
            nodeStack.push(*node.right);
        }  
    }
    // 最后将数列反转，实现左右中
    reverse(order.begin(), order.end());
    return order;
}

/*
* 中序遍历的特殊性：
*     1. 二叉树的遍历中，共分为两步：访问节点和处理节点。
*     2. 对于前序和后续遍历：
*            前序 - 先访问后遍历
*            后序 - 先遍历后访问
*     3. 而中序遍历，他是遍历-访问-遍历。因此中序遍历特殊
* 详细来讲，树的遍历实际上分为两个阶段：遍历和访问。
* 遍历时，永远都是从左走，走到头回头，再走到右边，再回头。一直重复，直到踩过每一个点。
* 而在这期间，什么是否访问决定了遍历的顺序类型。每个节点应该都会被踩点 3 次，对于缺少孩子的节点，其可能会有“原地踏步”的情况。
* 先序遍历就是访问的顺序和遍历的顺序相同。后序遍历就是遍历的顺序是访问顺序的逆过程。
* 而中序遍历却不同，它是在走完左边的时候，正准备走右边时才访问节点。这也就说明为什么中序和前序和后序在非递归上不太一样。
* 因此，中序的思路在于：
*     1. 首先栈的作用发生变化，入栈的顺序就是遍历的顺序，即遍历一个，入栈一个。
*     2. 设立一个指针，用于记录当前遍历的情况，可以叫“遍历指针”（注意：当孩子为 NULL 时，“遍历指针”也会走到孩子那去，回头正好是叶子节点）
*     3. 只有当“遍历指针”回头，即第二次访问到节点时，出栈（此时“遍历指针”指向的节点肯定和栈顶元素一样，是同一个节点）
*/
vector<int> traverse(BitNode head)
{
    stack<BitNode> nodeStack;
    vector<int> order;
    BitNode* currentNode = &head;
    // 当栈为空时，如果当前指针也为空（此时肯定是指向最后一个节点的右孩子（空））时，整个过程才代表结束。
    while (!nodeStack.empty() || currentNode != NULL)
    {
        // 不为空就入栈、一路向左
        if (currentNode != nullptr)
        {
            nodeStack.push(*currentNode);
            currentNode = currentNode->left;
        }
        // 如果为空，那就出栈，访问，回退，向右走
        else
        {
            // 出栈
            BitNode node = nodeStack.top();
            nodeStack.pop();
            // 访问
            order.push_back(node.value);
            // 回退
            // currentNode = &node;
            // 向右走
            currentNode = node.right;
        }
    }
    return order;
}

int main()
{
    //      4
    //   5     3
    //     1 7
    BitNode head(4);
    BitNode leftNode(5);
    BitNode rightNode(3);
    BitNode leaf_1(1);
    BitNode leaf_2(7);
    head.left = &leftNode;
    head.right = &rightNode;
    leftNode.right = &leaf_1;
    rightNode.left = &leaf_2;
    vector<int> order = preorderedTraverse(head);
    for (int i = 0; i < order.size(); i++)
    {
        cout << order[i] << "  ";
    }
    cout << endl;
    order = afterOrderedTraverse(head);
    for (int i = 0; i < order.size(); i++)
    {
        cout << order[i] << "  ";
    }
    cout << endl;
    order = traverse(head);
    for (int i = 0; i < order.size(); i++)
    {
        cout << order[i] << "  ";
    }
    cout << endl;
}
```

#### 5.2.2 要点总结

1. 详见代码注释，主要是中序和前后的差别。

### 5.3 二叉树的统一迭代遍历（记住，这个好记）

#### 5.3.1 代码

```cpp
// 统一化的二叉树遍历
#include <iostream>
#include <stack>
#include <vector>
using namespace std;

struct BitNode
{
    int value;
    BitNode* left;
    BitNode* right;
    BitNode(int value) : value(value), left(nullptr), right(nullptr) {}
};

// 中序遍历
vector<int> traverse(BitNode head)
{
    // 入栈的顺序和遍历的顺序相同
    // 注意这里的栈改存节点指针，因为这样才能存 NULL，普通的结构体变量没有 NULL
    // NULL 作为标记，表示弹出这个时，下一个栈的节点就是要访问的节点
    stack<BitNode*> traceStack;
    vector<int> result;
    traceStack.push(&head);
    // 用一个变量来记录出栈的元素
    BitNode* node = nullptr;
    while (!traceStack.empty())
    {
        node = traceStack.top();
        traceStack.pop();
        // 如果弹出的节点不是标记，表示要遍历
        if (node != nullptr)
        {
            // 遍历的顺序是左中右，那么入栈顺序就是右中左
            // 此时中间的元素是要访问的元素，因此在遍历到中间的元素时，塞个标记位子
            if (node->right != nullptr)
            {
                traceStack.push(node->right);
            }
            traceStack.push(node);
            // 塞入标记
            traceStack.push(nullptr);
            if (node->left != nullptr)
            {
                traceStack.push(node->left);
            }
        }
        // 如果弹出的是标记，那就再弹出一个（此时这个肯定是中间节点），然后访问
        if (node == nullptr)
        {
            node = traceStack.top();
            traceStack.pop();
            // 访问
            result.push_back(node->value);
        }
    }
    return result;
}

// 前序遍历
vector<int> preOrderedTraverse(BitNode head)
{
    // 出栈的顺序和遍历的顺序相同
    // 注意这里的栈改存节点指针，因为这样才能存 NULL，普通的结构体变量没有 NULL
    // NULL 作为标记，表示弹出这个时，下一个栈的节点就是要访问的节点
    stack<BitNode*> traceStack;
    vector<int> result;
    traceStack.push(&head);
    // 用一个变量来记录出栈的元素
    BitNode* node = nullptr;
    while (!traceStack.empty())
    {
        node = traceStack.top();
        traceStack.pop();
        // 如果弹出的节点不是标记，表示要遍历
        if (node != nullptr)
        {
            if (node->right != nullptr)
            {
                traceStack.push(node->right);
            }
            if (node->left != nullptr)
            {
                traceStack.push(node->left);
            }
            // 先遍历中间，然后塞入中间节点
            traceStack.push(node);
            // 塞入标记
            traceStack.push(nullptr);
        }
        // 如果弹出的是标记，那就再弹出一个（此时这个肯定是中间节点），然后访问
        if (node == nullptr)
        {
            node = traceStack.top();
            traceStack.pop();
            // 访问
            result.push_back(node->value);
        }
    }
    return result;
}

// 后序遍历
vector<int> afterOrderedTraverse(BitNode head)
{
    // 出栈的顺序和遍历的顺序相同
    // 注意这里的栈改存节点指针，因为这样才能存 NULL，普通的结构体变量没有 NULL
    // NULL 作为标记，表示弹出这个时，下一个栈的节点就是要访问的节点
    stack<BitNode*> traceStack;
    vector<int> result;
    traceStack.push(&head);
    // 用一个变量来记录出栈的元素
    BitNode* node = nullptr;
    while (!traceStack.empty())
    {
        node = traceStack.top();
        traceStack.pop();
        // 如果弹出的节点不是标记，表示要遍历
        if (node != nullptr)
        {
            // 中
            traceStack.push(node);
            traceStack.push(nullptr);
            // 右
            if (node->right != nullptr)
            {
                traceStack.push(node->right);
            }
            // 左
            if (node->left != nullptr)
            {
                traceStack.push(node->left);
            }
        }
        // 如果弹出的是标记，那就再弹出一个（此时这个肯定是中间节点），然后访问
        if (node == nullptr)
        {
            node = traceStack.top();
            traceStack.pop();
            // 访问
            result.push_back(node->value);
        }
    }
    return result;
}

int main()
{
    //      4
    //   5     3
    //     1 7
    BitNode head(4);
    BitNode leftNode(5);
    BitNode rightNode(3);
    BitNode leaf_1(1);
    BitNode leaf_2(7);
    head.left = &leftNode;
    head.right = &rightNode;
    leftNode.right = &leaf_1;
    rightNode.left = &leaf_2;
    vector<int> result = traverse(head);
    for (int i = 0; i < result.size(); i++)
    {
        cout << result[i] << "  ";
    }
    cout << endl;
    result = preOrderedTraverse(head);
    for (int i = 0; i < result.size(); i++)
    {
        cout << result[i] << "  ";
    }
    cout << endl;
    result = afterOrderedTraverse(head);
    for (int i = 0; i < result.size(); i++)
    {
        cout << result[i] << "  ";
    }
    cout << endl;

}
```

#### 5.3.2 要点总结

1. 统一迭代中，栈的作用进行了统一，因此记忆负担小。

### 5.4 二叉树的层序遍历

#### 5.4.1 代码

```cpp
// 层序遍历
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

struct BitNode
{
    int value;
    BitNode* left;
    BitNode* right;
    BitNode(int value) : value(value), left(nullptr), right(nullptr) {};
};

// 非递归层序遍历
vector<vector<int>> noRecursionLevelOrderedTraverse(const BitNode head)
{
    vector<vector<int>> results;
    queue<BitNode> level;
    level.push(head);
    while (!level.empty())
    {
        vector<int> result;
        int round = level.size();
        // 一轮循环
        for (int i = 0; i < round; i++)
        {
            // 出队
            BitNode node = level.front();
            level.pop();
            // 访问
            result.push_back(node.value);
            // 左右孩子入队
            if (node.left != nullptr)
            {
                level.push(*node.left);
            }
            if (node.right != nullptr)
            {
                level.push(*node.right);
            }
        }
        results.push_back(result);
    }
    return results;
}

/*
* 递归的层序遍历，因为是递归，所以不需要队列
*/
void levelOrderedTraverse(const BitNode* node, vector<vector<int>>& results, int depth)
{
    // 递归的退出条件
    if (node == nullptr)
    {
        return;
    }
    // 初始化
    if (results.size() <= depth) results.push_back(vector<int>());
    // 访问
    results[depth].push_back(node->value);
    // 左孩子
    levelOrderedTraverse(node->left, results, depth + 1);
    // 右孩子
    levelOrderedTraverse(node->right, results, depth + 1);
}

int main()
{
    //      4
    //   5     3
    //     1 7
    BitNode head(4);
    BitNode leftNode(5);
    BitNode rightNode(3);
    BitNode leaf_1(1);
    BitNode leaf_2(7);
    head.left = &leftNode;
    head.right = &rightNode;
    leftNode.right = &leaf_1;
    rightNode.left = &leaf_2;
    vector<vector<int>> results = noRecursionLevelOrderedTraverse(head);
    for (int i = 0; i < results.size(); i++)
    {
        for (int j = 0; j < results[i].size(); j++)
        {
            cout << results[i][j] << "  ";
        }
        cout << endl;
    }
    vector<vector<int>> results2;
    levelOrderedTraverse(&head, results2, 0);
    for (int i = 0; i < results2.size(); i++)
    {
        for (int j = 0; j < results2[i].size(); j++)
        {
            cout << results2[i][j] << "  ";
        }
        cout << endl;
    }
}
```

#### 5.4.2 要点总结

1. 递归遍历注意他多了一个“参数”。
2. 迭代遍历注意他一轮循环的次数是怎么定的。

### 5.5 翻转二叉树

#### 5.5.1 代码

```cpp
// 翻转二叉树
#include <iostream>
#include <queue>
using namespace std;

struct BitNode
{
    int value;
    BitNode* left;
    BitNode* right;
    BitNode(int value) : value(value), left(nullptr), right(nullptr) {};
};

// 用递归写
void reverseTree(BitNode* node)
{
    // 先访问，然后左、右
    // 左指针和右指针的内容颠倒
    BitNode* temp = node->left;
    node->left = node->right;
    node->right = temp;
    temp = nullptr;
    delete temp;
    if (node->left != nullptr)
    {
        reverseTree(node->left);
    }
    if (node->right != nullptr)
    {
        reverseTree(node->right);
    }
}

/*
* 使用中序遍历打印树
*/
void printTree(BitNode* node, vector<int>& result)
{
    if (node->left != nullptr)
    {
        printTree(node->left, result);
    }
    result.push_back(node->value);
    if (node->right != nullptr)
    {
        printTree(node->right, result);
    }
    
}

int main()
{
    //          5                5
    //      4       6 ->      6     4
    //        7   3             3  7
    BitNode* head = new BitNode(5);
    head->left = new BitNode(4);
    head->right = new BitNode(6);
    head->left->right = new BitNode(7);
    head->right->left = new BitNode(3);
    vector<int> result;
    reverseTree(head);
    printTree(head, result);
    for (int i = 0; i < result.size(); i++)
    {
        cout << result[i] << "  ";
    }
    cout << endl;
}
```

#### 5.5.2 要点总结

1. 一般树的题目中，前序和后序用的比较多。本地用中序，就会出现问题。

### 5.6 对称二叉树

#### 5.6.1 代码

```cpp
// 判断镜像树
#include <iostream>
using namespace std;

struct BitNode
{
    int value;
    BitNode* left;
    BitNode* right;
    BitNode(int value) : value(value), left(nullptr), right(nullptr) {};
};

/*
* 思路一：
* 左子树翻转，得到的新树和右子树进行判断（通过对比前序和中序）
*/

/*
* 思路二：
* 左子树“中左右”，右子树“中右左”，两个数组对应位置相等？
* 应该是每一次递归一个点就要比较一次
* 递归可以通过传 2 个参数，以同时进行
*/
void compareBitNode(BitNode* node1, BitNode* node2, bool& isEqual)
{
    if ((node1 == nullptr && node2 != nullptr) || (node1 != nullptr && node2 == nullptr))
    {
        isEqual = false;
        return;
    }
    else if (node1 != nullptr && node2 != nullptr && node1->value != node2->value)
    {
        isEqual = false;
        return;
    }
    else if(node1 == nullptr && node2 == nullptr)
    {
        return;
    }
    //cout << isEqual << endl;
    compareBitNode(node1->left, node2->right, isEqual);
    compareBitNode(node1->right, node2->left, isEqual);
}

/*
* 思路三：
* 后序遍历
*/

int main()
{
    
    //              5
    //           3     3
    //         1   2 2   1
    BitNode* mirrorTree = new BitNode(5);
    mirrorTree->left = new BitNode(3);
    mirrorTree->right = new BitNode(3);
    mirrorTree->left->left = new BitNode(1);
    mirrorTree->left->right = new BitNode(2);
    mirrorTree->right->left = new BitNode(2);
    mirrorTree->right->right = new BitNode(1);
    //mirrorTree->left->left->left = new BitNode(1);
    //              5
    //           4     3
    //         1   2 2   1
    BitNode* tree = new BitNode(5);
    tree->left = new BitNode(4);
    tree->right = new BitNode(3);
    tree->left->left = new BitNode(1);
    tree->left->right = new BitNode(2);
    tree->right->left = new BitNode(2);
    tree->right->right = new BitNode(1);

    bool isEqual = true;
    compareBitNode(mirrorTree->left, mirrorTree->right, isEqual);
    cout << "是否为镜像树：" << isEqual << endl;
    compareBitNode(tree->left, tree->right, isEqual);
    cout << "是否为镜像树：" << isEqual << endl;
}
```

####  5.6.2 要点总结

1. 标准答案给的是后序遍历，递归 bool 返回值在“中”时进行处理。前序遍历多传了参数，写的有点冗余。

### 5.7 二叉树的最大深度

#### 5.7.1 代码

```cpp
// 求一颗二叉树的深度
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

struct BitNode
{
    int value;
    BitNode* left;
    BitNode* right;
    BitNode(int value) : value(value), left(nullptr), right(nullptr) {};
};

// 层次遍历
int levelTraverse(BitNode* head)
{
    vector<vector<int>> results;
    queue<BitNode*> levelQueue;
    levelQueue.push(head);
    while (!levelQueue.empty())
    {
        vector<int> result;
        int round = levelQueue.size();
        for (int i = 0; i < round; i++)
        {
            BitNode* temp = levelQueue.front();
            levelQueue.pop();
            result.push_back(temp->value);
            if (temp->left)
            {
                levelQueue.push(temp->left);
            }
            if (temp->right)
            {
                levelQueue.push(temp->right);
            }
        }
        results.push_back(result);
    }
    return results.size();
}

/*
* 思路二：后序遍历
* 前序遍历从上往下，后序遍历从下网上，将数据返回给根节点。
* 因此求一棵树的深度用前序遍历，求一棵树的高度用后序遍历。
* 因为求最大深度，实际上就是求根节点的高度，因此可以采用后序遍历（递归），
* 一层一层向上传 max(左高 + 右高） + 1
*/

int main()
{   
    //              5
    //           4     3
    //         1   2 2   1
    BitNode* tree = new BitNode(5);
    tree->left = new BitNode(4);
    tree->right = new BitNode(3);
    tree->left->left = new BitNode(1);
    tree->left->right = new BitNode(2);
    tree->right->left = new BitNode(2);
    tree->right->right = new BitNode(1);

    int depth = levelTraverse(tree);
    cout << "深度为：" << depth << endl;
}
```

#### 5.7.2 要点总结

1. 理解二叉树的“高度”和“深度”
2. 最大深度 = 最大高度

### 5.8 二叉树的最小深度

#### 5.8.1 代码

```cpp
// 求树的最小深度
#include <iostream>
#include <math.h>
using namespace std;

struct BitNode
{
    int value;
    BitNode* left;
    BitNode* right;
    BitNode(int value) : value(value), left(nullptr), right(nullptr) {  }
};

/*
* 使用后序遍历获取高度
*/
int getMinDepth(BitNode* node)
{
    if (!node)
    {
        return 0;
    }
    if (node->left == nullptr && node->right != nullptr)
    {
        return getMinDepth(node->right) + 1;
    }
    else if (node->left != nullptr && node->right == nullptr)
    {
        return getMinDepth(node->left) + 1;
    }
    else if (node->left == nullptr && node->right == nullptr)
    {
        return 1;
    }
    else
    {
        return (int)fmin(getMinDepth(node->left), getMinDepth(node->right)) + 1;
    }
}


int result = INT16_MAX;
/*
* 使用前序遍历获取深度
* 前序遍历一般可以不考虑返回值，而且参数可能大于 1
*/
void getMinDepth(BitNode* node, int depth)
{
    if (!node)
    {
        return;
    }
    if (node->left == nullptr && node->right == nullptr)
    {
        result = min(depth, result);
        return;
    }
    if (node->left)
    {
        getMinDepth(node->left, depth + 1);
    }
    if (node->right)
    {
        getMinDepth(node->right, depth + 1);
    }
}

int main()
{
    BitNode* head = new BitNode(1);
    head->right = new BitNode(2);
    head->right->left = new BitNode(4);
    head->right->right = new BitNode(3);
    head->right->right->left = new BitNode(6);
    head->right->right->right = new BitNode(5);
    int minDepth = getMinDepth(head);
    cout << "最小深度为：" << minDepth << endl;
    getMinDepth(head, 1);
    cout << "最小深度为：" << result << endl;
}
```

#### 5.8.2 要点总结

1. 最小深度是从根节点**到最近叶子节点**的最短路径上的节点数量。

### 5.9 完全二叉树的节点个数

#### 5.9.1 代码

```cpp
// 完全二叉树的点数量
#include <iostream>
#include <math.h>
using namespace std;

struct BitNode
{
    int value;
    BitNode* left;
    BitNode* right;
    BitNode(int value) : value(value), left(nullptr), right(nullptr) {  };
};

/*
* 1. 判断左右子树是否为 FBT
* 2. 是的话就套公式
* 3. 不是的话就向下分解遍历
*/
int getNums(BitNode* node)
{
    if (!node)
    {
        return 0;
    }
    int leftDepth = getLeftDepth(node);
    int rightDepth = getRightDepth(node);
    if (leftDepth == rightDepth)
    {
        return pow(2, leftDepth) - 1;
    }
    else
    {
        return getNums(node->left) + getNums(node->right) + 1;
    }
}

int getLeftDepth(BitNode* node)
{
    if (node->left)
    {
        return getLeftDepth(node->left) + 1;
    }
    else
    {
        return 1;
    }
}
int getRightDepth(BitNode* node)
{
    if (node->right)
    {
        return getRightDepth(node->right) + 1;
    }
    else
    {
        return 1;
    }
}

int main()
{
    
}
```

#### 5.9.2 要点总结

1. 完全二叉树递归到某一深度**一定**会有左孩子或者右孩子为满二叉树

### 5.10 平衡二叉树

#### 5.10.1 代码

```cpp
// AVL 树的判断
#include <iostream>
using namespace std;

struct BitNode
{
    int value;
    BitNode* left;
    BitNode* right;
    BitNode(int value) : value(value), left(nullptr), right(nullptr) {}
};

/**
 * 后序遍历返回高度.
 * 
 * \param node 每次遍历的节点指针
 * \param isAVL 传入优先为 true
 * \return 子树的高度
 */
int getHeight(const BitNode* node, bool& isAVL)
{
    if (!node)
    {
        return 0;
    }
    // 左
    int leftHeight = getHeight(node->left, isAVL);
    // 右
    int rightHeight = getHeight(node->right, isAVL);
    // 中
    if (abs(rightHeight - leftHeight) > 1)
    {
        isAVL = false;
    }
    return max(leftHeight, rightHeight) + 1;
}

/**
 * 换一种写法.
 * 
 * \param node
 * \return 
 */
int getHeight(const BitNode* node)
{
    if (!node)
    {
        return 0;
    }
    // 左
    int leftHeight = getHeight(node->left);
    if (leftHeight == -1)
    {
        return -1;
    }
    // 右
    int rightHeight = getHeight(node->right);
    if (rightHeight == -1)
    {
        return -1;
    }
    // 中
    if (abs(rightHeight - leftHeight) > 1)
    {
        return -1;
    }
    return max(leftHeight, rightHeight) + 1;
}

int main()
{
    BitNode* head = new BitNode(0);
    head->left = new BitNode(0);
    head->right = new BitNode(0);
    head->left->left = new BitNode(0);
    head->left->right = new BitNode(0);
    head->right->left = new BitNode(0);
    head->right->right = new BitNode(0);
    head->right->right->left = new BitNode(0);
    head->right->right->right = new BitNode(0);
    //head->right->right->right->right = new BitNode(0);
    bool isAVL = true;
    /*getHeight(head, isAVL);*/
    cout << "是二叉树吗：" << isAVL << endl;
}
```

#### 5.10.2 要点总结

1. 二叉树中别忘了高度差可以为 -1。

### 5.11 二叉树的所有路径

#### 5.11.1 代码

```cpp
// 求所有叶子节点的路径
#include <iostream>
#include <vector>
#include <string>
using namespace std;

struct BitNode
{
    int value;
    BitNode* left;
    BitNode* right;
    BitNode(int value) : value(value), left(nullptr), right(nullptr) {}
};

/**
 * 这题涉及到回溯，可以去看代码随想录中针对“回溯”的写法，去学习回溯.
 */
vector<string> paths;
void getPath(BitNode* node, string path)
{
    // 中
    path = path + to_string(node->value) + "->";
    // 左
    if (node->left)
    {
        getPath(node->left, path);
    }
    // 右
    if (node->right)
    {
        getPath(node->right, path);
    }
    if (node->left == nullptr && node->right == nullptr)
    {
        paths.push_back(path.substr(0, path.size() - 2));
    }
}


int main()
{
    BitNode* head = new BitNode(1);
    head->left = new BitNode(2);
    head->right = new BitNode(3);
    head->left->left = new BitNode(5);
    getPath(head, "");
    for (int i = 0; i < paths.size(); i++)
    {
        cout << paths[i] << endl;
    }
}
```

#### 5.11.2 要点总结

1. **回溯和递归是一一对应的，有一个递归，就要有一个回溯**
2. 回溯详见[回溯](https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html#%E6%80%9D%E8%B7%AF)

### 5.12 左叶子之和

#### 5.12.1 代码

```cpp
// 所有左叶子之和
#include <iostream>
using namespace std;

struct BitNode
{
    int value;
    BitNode* left;
    BitNode* right;
    BitNode(int value) : value(value), left(nullptr), right(nullptr) {};
};

void allLeftLeaves(BitNode* node, int& sum, bool isLeft)
{
    // 中
    if (node->left == nullptr && node->right == nullptr && isLeft)
    {
        sum += node->value;
        return;
    }
    if (node->left)
    {
        allLeftLeaves(node->left, sum, true);
    }
    if (node->right)
    {
        allLeftLeaves(node->right, sum, false);
    }
}

int main()
{
    BitNode* head = new BitNode(1);
    head->right = new BitNode(2);
    int sum = 0;
    allLeftLeaves(head, sum, false);
    cout << "左子树的总和为：" << sum << endl;
    BitNode* head2 = new BitNode(3);
    head2->left = new BitNode(9);
    head2->right = new BitNode(20);
    head2->left->left = new BitNode(6);
    head2->left->right = new BitNode(7);
    head2->right->left = new BitNode(15);
    head2->right->right = new BitNode(7);
    sum = 0;
    allLeftLeaves(head2, sum, false);
    cout << "左子树的总和为：" << sum << endl;
}
```

#### 5.12.2 要点总结

1. 标准答案是**判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。**

### 5.13 二叉树的最下左的值

#### 5.13.1 代码

```cpp
// 找到最左下的叶子（优先下，然后左）
#include <iostream>
#include <queue>
using namespace std;

struct BitNode
{
	int val;
	BitNode* left;
	BitNode* right;
	BitNode(int value) : val(value), left(nullptr), right(nullptr) {};
};

void getNorthWest(const BitNode* node, int& number, int depth, int& depthest)
{
	// 中
	if (depth > depthest)
	{
		depthest = depth;
		number = node->val;
	}
	// 左
	if (node->left)
	{
		getNorthWest(node->left, number, depth + 1, depthest);
	}
	// 右
	if (node->right)
	{
		getNorthWest(node->right, number, depth + 1, depthest);
	}
}

/**
 * 使用层序遍历.
 * 
 * \param head
 * \return 
 */
int getNorthWest(BitNode* head)
{
	if (!head)
	{
		return 0;
	}
	int number = head->val;
	queue<BitNode*> nodeQueue;
	nodeQueue.push(head);
	while (!nodeQueue.empty())
	{
		number = nodeQueue.front()->val;
		int round = nodeQueue.size();
		for (int i = 0; i < round; i++)
		{
			BitNode* node = nodeQueue.front();
			nodeQueue.pop();
			if (node->left)
			{
				nodeQueue.push(node->left);
			}
			if (node->right)
			{
				nodeQueue.push(node->right);
			}
		}
	}
	return number;
}

int main()
{
	BitNode* head = new BitNode(1);
	head->left = new BitNode(2);
	head->right = new BitNode(3);
	head->left->left = new BitNode(4);
	head->right->left = new BitNode(5);
	head->right->right = new BitNode(6);
	head->right->left->left = new BitNode(7);

	int depthest = 0;
	int number = head->val;
	getNorthWest(head, number, 0, depthest);
	cout << "最下左的值为：" << number << endl;
	cout << "最下左的值为：" << getNorthWest(head) << endl;
}
```

#### 5.13.2 要点总结

1. 暂时想不到

### 5.14 路径总和

#### 5.14.1 代码

```cpp
// 给定一个二叉树和一个目标和，
// 判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
#include <iostream>
using namespace std;

struct BitNode
{
	int val;
	BitNode* left;
	BitNode* right;
	BitNode(int value) : val(value), left(nullptr), right(nullptr) {};
};

/**
 * Todo: 也可以返回 bool，在“左右”的时候进行判断，如果满足条件就直接一路向上返回 true（用 number 去减，然后用“回溯”）
 * 
 * \param node
 * \param target
 * \param sum
 * \param hasTarget
 */
void hasTargetFunc(BitNode* node, const int target, int sum, bool& hasTarget)
{
	if (!node)
	{
		return;
	}
	// 中
	sum += node->val;
	// 这里只适用于整数，适当的剪枝了
	if (sum == target && node->left == nullptr && node->right == nullptr)
	{
		hasTarget = true;
		return;
	}
	// 左
	if (node->left != nullptr && node->left->val + sum <= target)
	{
		hasTargetFunc(node->left, target, sum, hasTarget);
	}
	// 右
	if (node->right != nullptr && node->right->val + sum <= target)
	{
		hasTargetFunc(node->right, target, sum, hasTarget);
	}
}

int main()
{
	BitNode* head = new BitNode(5);
	head->left = new BitNode(4);
	head->right = new BitNode(8);
	head->left->left = new BitNode(11);
	head->right->left = new BitNode(13);
	head->right->right = new BitNode(4);
	head->left->left->left = new BitNode(7);
	head->left->left->right = new BitNode(2);
	head->right->right->right = new BitNode(1);

	bool hasTarget = false;
	hasTargetFunc(head, 22, 0, hasTarget);
	cout << "是否有数：" << hasTarget << endl;
	hasTargetFunc(head, 23, 0, hasTarget = 0);
	cout << "是否有数：" << hasTarget << endl;
}
```

#### 5.14.2 要点总结

1. 学习[递归的处理和回溯](https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html#%E6%80%9D%E8%B7%AF)

### 5.15 中序和后序构造二叉树

#### 5.15.1 代码

```cpp
// 从后序数组和中序数组中构造二叉树
#include <iostream>
#include <vector>
using namespace std;

struct BitNode
{
    int val;
    BitNode* left;
    BitNode* right;
    BitNode(int val) : val(val), left(nullptr), right(nullptr) { };
};

void traverse(BitNode* node, vector<int> inOrder, vector<int> postOrder)
{
    if (!node || inOrder.size() == 0 || postOrder.size() == 0)
    {
        return;
    }
    // 首先区间分割的原则是“左闭右闭”
    // 1. 找后序数组的最后一个节点，作为节点元素
    node->val = postOrder.back();
    //cout << node->val << endl;
    postOrder.pop_back();
    // 2. 找到之后，到中序数组中将其分割开
    int prePivot = 0;
    for (int i = 0; i < inOrder.size(); i++)
    {
        if (inOrder[i] == node->val)
        {
            prePivot = i;
            break;
        }
    }
    cout << prePivot << "   " << inOrder.size() << endl;
    // 3. 根据中序数组，后序数组也要切割开，根据数量来看，应该左边的数组大小和中序左边的大小相同
    // 4. 递归回到第一步
    if (prePivot != 0)
    {
        node->left = new BitNode(INT_MAX);
        vector<int> newInOrder(inOrder.begin(), inOrder.begin() + prePivot);
        vector<int> newPostOrder(postOrder.begin(), postOrder.begin() + prePivot);
        traverse(node->left, newInOrder, newPostOrder);
    }
    if (prePivot != inOrder.size() - 1)
    {
        node->right = new BitNode(INT_MAX);
        vector<int> newInOrder(inOrder.begin() + prePivot + 1, inOrder.end());
        vector<int> newPostOrder(postOrder.begin() + prePivot, postOrder.end());
        traverse(node->right, newInOrder, newPostOrder);
    }
}

/**
 * 递归中不改变（包括不用回溯）的变量，可以使用 & 来避免重复创建多个函数形参，
 * 从而节省内存并提高速度，如果想避免在函数中误操作改变，还可以加 const
 * 
 * \param node
 * \param inOrder
 * \param postOrder
 * \param inOrderBegin
 * \param inOrderEnd
 * \param postOrderBegin
 * \param postOrderEnd
 */
void traverse(BitNode* node, 
    const vector<int>& inOrder, 
    const vector<int>& postOrder, 
    int inOrderBegin, 
    int inOrderEnd, 
    int postOrderBegin, 
    int postOrderEnd)
{
    if (!node || inOrder.size() == 0 || postOrder.size() == 0)
    {
        return;
    }
    // 首先区间分割的原则是“左闭右闭”
    // 1. 找后序数组的最后一个节点，作为节点元素
    node->val = postOrder[postOrderEnd];
    //cout << node->val << endl;
    // 注意这里进行了 -- 操作
    postOrderEnd--;
    // 2. 找到之后，到中序数组中将其分割开
    int prePivot = 0;
    for (int i = 0; i <= inOrderEnd - inOrderBegin; i++)
    {
        if (inOrder[i + inOrderBegin] == node->val)
        {
            prePivot = i;
            break;
        }
    }
    cout << prePivot << endl;
    // 3. 根据中序数组，后序数组也要切割开，根据数量来看，应该左边的数组大小和中序左边的大小相同
    // 4. 递归回到第一步
    if (prePivot != 0)
    {
        node->left = new BitNode(INT_MAX);
        // 上一个他取子区间函数是左闭右开的取，下标的话是取得到，这里用的是下标，注意！
        traverse(node->left, inOrder, postOrder, inOrderBegin, inOrderBegin + prePivot - 1, postOrderBegin, postOrderBegin + prePivot - 1);
    }
    if (prePivot != inOrderEnd - inOrderBegin)
    {
        node->right = new BitNode(INT_MAX);
        traverse(node->right, inOrder, postOrder, inOrderBegin + prePivot + 1, inOrderEnd, postOrderBegin + prePivot, postOrderEnd);
    }
}


int main()
{
    vector<int> inOrder = {9, 3, 15, 20, 7};
    vector<int> postOrder = { 9, 15, 7, 20, 3 };
    BitNode* root = new BitNode(INT_MAX);
    traverse(root, inOrder, postOrder);
    traverse(root, inOrder, postOrder, 0, inOrder.size() - 1, 0, postOrder.size() - 1);
}
```

#### 5.15.2 要点总结

1. 本质是区间划分的问题，细节来源自“循环不变量”

### 5.16 最大二叉树

#### 5.16.1 代码

```cpp
// 根据条件创建最大二叉树
#include <iostream>
#include <vector>
using namespace std;

struct BitNode
{
    int val;
    BitNode* left;
    BitNode* right;
    BitNode(int val) : val(val), left(nullptr), right(nullptr) { };
};

/**
 * 区间采用闭区间.
 * 
 * \param node
 * \param nums
 * \param begin
 * \param end
 */
void maxTree(BitNode* node, const vector<int>& nums, int begin, int end)
{
    if (!node || nums.size() == 0)
    {
        return;
    }
    // 1. 找最大值和所在下标
    // 偏移量
    int maxPivot = 0;
    for (int i = 0; i <= end - begin; i++)
    {
        if (node->val < nums[i + begin])
        {
            node->val = nums[i + begin];
            maxPivot = i;
        }
    }
    // 2. 将其分开
    if (maxPivot != 0)
    {
        node->left = new BitNode(INT_MIN);
        maxTree(node->left, nums, begin, begin + maxPivot - 1);
    }
    if (maxPivot != end - begin)
    {
        node->right = new BitNode(INT_MIN);
        maxTree(node->right, nums, begin + maxPivot + 1, end);
    }
}

int main()
{
    std::cout << "Hello World!\n";
}
```

#### 5.16.2 要点总结

1. 区间划分题，尽量用下标来划分，而不是单独创建内存来存放，这样可以缩小空间。













